\chapter{Conclusions}

We presented a visual debugging and exploration tool capable of showing how paths shot by a path tracer interact with the scene. We showed how the tool is structured in a data gathering part and a visualization client one; the gatherer can be plugged into the code of pre-existing path tracers as a library and dumps the needed data on disk during rendering; the client lets users explore the gathered data. Due to the sheer amount of paths a tracer has to shoot, we showed how the provided filtering tools, combined with the visualization widgets and options help users in exploring the datasets with relative ease. We dived into the implementation details of the bits that make our tool unique and into the performance exploits to speed up operations that would not be possible otherwise.
Such as, to name one, the multi-pass rendering pipeline that lets user visually explore hundreds of thousands of paths on a personal computer. We also detailed two couples of datasets that show the capabilities of the previously introduced features combined, partially demonstrating how the tool can be used as both a valid debug framework for path tracers and as an educational tool to explain with practical examples how a tracer works under the hood.

\section{Future developments}

The tool we presented is far from being defined complete. Several improvements can be done all over and many have been noted and described throughout this document. Many others, though, since not inherent to any particular feature are gathered here.

\begin{description}
	\item[More filters] Several path selection filters have been imagined during development, such as one excluding paths carrying less than a threshold radiance or another selecting paths only shot from a set of pixels selected via the \textbf{“Image”} panel. Interesting was the idea of extending the sphere filter adding a sort of \textit{sub-filters} such as one selecting the paths both bouncing in the sphere and bouncing in a user-controlled cone of directions; that would have been for example helpful for focusing on paths going toward a light after bouncing on an interesting surface patch. Another useful sphere filter sub-filter would have been one splitting between the bounces that have their direction sampled from the surface material and the ones that sampled scene lights; it would have been helpful in both examples of chapter \ref{results} but implementing it would have meant almost doubling the memory footprint of each bounce. 
	\item[Save and load status] The visualization client has several parameters of which settings are lost every time the application is closed. Useful with no doubts to every user would be a save and load feature for the parameter settings. Since most parameters are controlled by ImGui widgets, maybe it would be clever to use the state preservation feature of the library.
	\item[Disk streaming] Every dataset we tested hardly went over 1 billion bounces, but production renders tend to have way more bounces: a Full HD ($1920 \times 1080$ pixels) render with 1024 spp has roughly double the bounces, which means a memory footprint twice as big. So much data will not entirely fit on the primary memory of most personal computers and it makes data streaming from disk an essential feature for those cases. Even with the most careful implementation, streaming would impact performances but having something working slow is better than something not working at all. 
	\item[Spatial acceleration structures] Talking about performances brings up a somehow obvious possible improvement: spatial acceleration structures. Embedding every bounce in a data structure such as a \textit{k-d tree} \cite{bentley1975multidimensional} and then storing the paths' topology --- so which bounces make each path --- in a separate data structure, would improve performances of many bits of the visualization tool. Consider how the current filtering options are all based upon spatial queries and how these could be immensely faster if bounces were in a acceleration structure. As already mentioned in section \ref{heatmap}, the same goes for the bounce density heatmap generation, which is currently the slowest process on our tool.
	\item[User testing] Assessing the usability and usefulness of a software piece is no easy task and is canonically delegated to user testing. Gathering people orbiting around path tracing and perform usability testings with them would surely give great insight on what features can be improved, added or discarded all together. 
\end{description}